---
title: "CMake vs Makefile"
date: "2025-07-12"
tags: ["cmake", "makefile", "build-system", "c-cpp"]
summary: "CMake와 Makefile의 차이점과 선택 기준은?"
---

# CMake와 Makefile의 차이점과 선택 기준

1. **CMake**와 **Makefile**은 모두 소프트웨어 개발에서 반복적인 빌드 작업을 자동화하는 데 사용됨
2. CMake는 빌드 스크립트를 자동으로 생성해주는 “메타 빌드 시스템”, Makefile은 빌드 과정을 직접 정의하는 “전통적인 빌드 스크립트”
3. 프로젝트 규모, 협업 환경, 지원하는 플랫폼/IDE 등에 따라 두 도구의 선택이 달라질 수 있음
4. 아래에서는 CMake와 Makefile의 개념, 특징, 주요 사용 사례, 그리고 장단점을 비교

---

## 📝 CMake vs Makefile의 기본 개념

### CMake

- CMake는 **크로스 플랫폼 빌드 자동화 도구 생성기**
- 사용자가 작성한 `CMakeLists.txt`를 바탕으로, 각 운영체제와 IDE에 맞는 빌드 파일(예: Makefile, Visual Studio 프로젝트 등)을 **자동으로 생성**
- 직접 빌드 명령을 수행하지 않고, 해당 플랫폼의 빌드 도구에 작업을 위임

### Makefile

- Makefile은 **빌드 규칙을 직접 정의**하는 파일
- `make`라는 도구가 Makefile을 해석하여 소스코드 컴파일, 링크 등 빌드 과정을 처리
- 개발자가 빌드 타깃, 의존성, 커맨드를 직접 명시하며, 대부분의 리눅스/유닉스 환경에서 기본 지원

```cmake
# CMake 예시
cmake_minimum_required(VERSION 3.10)
project(MyApp)
add_executable(myapp main.cpp)
```

```makefile
# Makefile 예시
main: main.o utils.o
    gcc -o main main.o utils.o
```

---

## 🔧 주요 사용 사례와 차이점

### 1. 프로젝트 규모 및 복잡성

- **Makefile**

  - 소규모, 단일 플랫폼 프로젝트에 적합
  - 간단한 빌드 자동화, 반복 작업 처리에 강점

- **CMake**

  - 대형 프로젝트, 다중 플랫폼, 여러 라이브러리·모듈 관리에 유리
  - 여러 빌드 옵션(디버그/릴리즈), 외부 의존성, 하위 프로젝트 관리에 최적

### 2. 플랫폼/툴체인/IDE 지원

- **Makefile**

  - 주로 유닉스/리눅스 기반(Windows에서는 별도 도구 필요)
  - 터미널 중심의 개발 환경에 최적화

- **CMake**

  - Windows, Linux, macOS, 임베디드 등 다양한 플랫폼 지원
  - Visual Studio, Xcode, VSCode, CLion 등 주요 IDE와 완벽하게 연동
  - CI/CD 환경에서 크로스 플랫폼 자동화에 강점

### 3. 유지보수 및 협업

- **Makefile**

  - 프로젝트가 커지면 관리가 어려워짐
  - 빌드 규칙, 옵션 변경 등 수정 시 실수 발생 확률 증가

- **CMake**

  - 복잡한 빌드 옵션과 의존성도 구조적으로 관리
  - 여러 사람이 다양한 환경에서 같은 프로젝트를 쉽게 빌드

---

## 🛠️ 장단점 비교

| 항목              | Makefile                                        | CMake                                         |
| ----------------- | ----------------------------------------------- | --------------------------------------------- |
| **초기 진입장벽** | 낮음 (간단한 규칙만 알면 바로 사용)             | 약간 높음 (CMake 문법/구조 파악 필요)         |
| **직접 제어**     | 빌드 과정을 상세하게 직접 통제 가능             | 추상화되어 자동 관리, 직접 세부 조정은 제한적 |
| **확장성**        | 대형/복잡한 프로젝트에서는 유지보수 어려움      | 확장성과 유지보수에 매우 강함                 |
| **이식성**        | 주로 리눅스/유닉스에 적합                       | 크로스 플랫폼/툴체인/IDE 지원                 |
| **IDE 연동성**    | 제한적 (터미널 중심, 별도 플러그인 필요)        | 대부분 IDE와 바로 연동                        |
| **협업/자동화**   | 간단한 작업에는 충분, 복잡한 자동화는 한계 있음 | 팀/CI/CD/자동화 등 복잡한 환경에 강점         |

---

## 🏁 결론

1. **소규모/단순 프로젝트** 또는 **리눅스 환경에서 빠른 빌드 자동화**가 필요하다면 Makefile이 충분
2. **대형 프로젝트, 크로스 플랫폼, IDE 연동, 협업**이 필요하다면 CMake가 훨씬 유리
3. 프로젝트 성격, 팀 규모, 목표 플랫폼에 따라 적합한 빌드 도구를 선택하는 것이 중요
4. 최근에는 CMake를 활용한 자동화·협업 환경 구축이 점점 표준으로 자리 잡는 추세
5. Makefile과 CMake를 적절히 이해하고 선택하면, 빌드 시스템 관리 효율성과 개발 생산성을 크게 높일 수 있음
6. 현업에서 오래된 임베디드 시스템에선 Makefile로 구성되어있을 확률이 높음
